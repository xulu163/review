package com.xulu.review.queue;

/**
 * jms是什么
 *
 * @author xulu  E-mail:java_xul@163.com
 * @version 1.0
 * @create 2019-07-08 11:49
 **/
public class JMSDemo {

    /**
     * 什么是jms？
     * Java Message Service（java消息服务，javaEE的一套规范）
     *
     * jms的其他落地产品
     * activemq、rabbitmq、rocketmq、kafka
     *
     * jms的三大元素：消息头、消息体、消息属性
     *
     *
     *消息头的特性：
     * 1。持久性和非持久性
     * 2。优先级：
     *
     * 3。唯一标识：用于防止重复消费
     *
     *消息体：封装具体的消息信息
     * 5种格式：
     * TextMessage:
     * MapMessage:
     * BytesMessage:
     * StreamMessage:
     * ObjectMessage:
     *
     *消息属性：
     *
     */


    /**
     * 消息的可靠性： 持久、事物、签收（确认机制）
     *
     * 1。持久性（非持久化和持久化）
     * 非持久化模式在down机后未消费的消息会丢失
     * 持久化模式在down机后未消费的消息不会丢失
     * 总结：持久化有利于消息的可靠性，默认的传送模式就是持久化模式，持久化
     * 模式保证消息只被传送一次和成功使用一次，可靠性是优先考虑的因素，
     * 可靠性的另一个重要方面是确保持久性消息传送至目标后，消息服务在向
     * 消费者传送之前不会丢失这些消息。
     *
     * 2。事务（生产者）
     * 如果启用了事务，必须手动commit消息才会提交到mq中。
     * 事务机制可以保证生产者多条消息同时成功提交到mq中，异常可以统一回滚；
     * 也可以在一定层度上避免消费者重复消费。
     *
     * 3。签收（消费者）
     * 自动签收：
     * 手动签收：
     *
     *
     * 如果是事务模式下，没有手动commit，会有重复消费；如果手动commit了，默认就是自动提交签收，不会重复消费；
     *
     */

    /**
     * 点对点和发布/订阅的小总结：
     * 点对点模型是基于队列的，生产者发消息到队列，消费者从队列接受消息，队列的存在使得消息的异步
     * 传输成为可能，和我们平时给朋友发送短信类似。
     * 1。如果在session关闭时有部分消息已被收到但还没有被签收，那当消费者下次连接到相同的队列时，
     * 这些消息还会被再次接收；
     * 2。队列可以长久地保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持
     * 激活的连接状态，充分体现了异步传输模式的优势。
     *
     *
     * 发布/订阅模式定义了如何向一个内容节点发布和订阅消息，这些节点被称为topic主题
     * 主题可以被认为时消息的传输中介，发布者发布消息到主题，订阅者从主题订阅消息。主题可以使得消息
     * 订阅者和消息发布者保持互相独立，不需要接触即可保证消息的传送。
     */



}
