package com.xulu.review.lock;

/**
 * 概念知识：java的15种锁
 *
 * @author xulu  E-mail:java_xul@163.com
 * @version 1.0
 * @create 2019-05-09 10:38
 **/
public class Basic {

    /**
     * 公平锁：是指多个线程按照申请的顺序来获取锁，类似排队打饭，先来后到。
     *
     * 非公平锁：直接尝试占有锁，如果尝试失败，就采用类似公平锁的方式获取。
     *
     * 可重入锁：又名递归锁，指的是统一线程外层函数获得锁之后，内层递归函数仍然能获得改锁的代码，在同一个线程在外层方法获取锁的时候，
     * 在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个他已经拥有的锁同步着的代码块，非公平锁的优点在于吞吐量大，
     * 对于synchronized而言，是一种非公平锁。
     *
     * 不可重入锁：不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。
     *
     * 独占锁：该锁每一次只能被一个线程所持有。
     *
     * 共享锁：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。
     *
     * 互斥锁：在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。
     * 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。
     * 如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态，
     * 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。
     * 在这种方式下，只有一个线程能够访问被互斥锁保护的资源
     *
     * 读写锁：
     *
     * 乐观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。
     *
     * 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。
     *
     * 分段锁：
     *
     * 偏向锁：
     *
     * 轻量级锁：
     *
     * 重量级锁：
     *
     * 自旋锁：
     */
}
